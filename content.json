{"meta":{"title":"summerain0的个人博客","subtitle":"","description":"这是summerain0的个人博客","author":"summerain0","url":"https://summerain0.club","root":"/"},"pages":[{"title":"所有分类","date":"2022-10-26T12:33:22.938Z","updated":"2022-09-02T09:13:40.433Z","comments":true,"path":"categories/index.html","permalink":"https://summerain0.club/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-11-27T01:51:01.676Z","updated":"2022-11-27T01:51:01.676Z","comments":true,"path":"about/index.html","permalink":"https://summerain0.club/about/index.html","excerpt":"","text":"欢迎About Me欢迎光临summerain0的个人小站，如你所见，这是一个博客网站，主要分享一些教程及个人遇到的问题及解决方法，希望对大家能有所帮助。 男 出不了校的苦逼大学生 日常码代码 啥都写一点，Android，JavaWeb，Vue.js …"},{"title":"","date":"2022-10-26T12:33:22.938Z","updated":"2022-09-02T09:14:28.678Z","comments":true,"path":"mylist/index.html","permalink":"https://summerain0.club/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2022-10-26T12:33:22.897Z","updated":"2022-09-02T10:04:36.710Z","comments":true,"path":"404.html","permalink":"https://summerain0.club/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有标签","date":"2022-10-26T12:33:22.938Z","updated":"2022-09-02T09:13:59.927Z","comments":true,"path":"tags/index.html","permalink":"https://summerain0.club/tags/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-10-26T12:33:22.938Z","updated":"2022-09-04T08:28:35.697Z","comments":true,"path":"comment/index.html","permalink":"https://summerain0.club/comment/index.html","excerpt":"","text":"Hello，来聊点什么呢？"},{"title":"友情链接","date":"2022-10-26T12:33:22.938Z","updated":"2022-09-02T11:10:49.102Z","comments":true,"path":"friends/index.html","permalink":"https://summerain0.club/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"Java新特性-Stream流","slug":"java-stream-usage","date":"2022-09-19T15:31:50.000Z","updated":"2022-09-21T12:40:07.536Z","comments":true,"path":"2022/09/19/java-stream-usage/","link":"","permalink":"https://summerain0.club/2022/09/19/java-stream-usage/","excerpt":"","text":"1. 什么是Stream流？Stream是一种类似于工厂的流水线的流式思想。在工厂的流水线上，我们可以在每个关口设置不同的条件进行筛选、检查并在尾部输出最终的成品，这里的Stream也可以这样理解。 2. 案例2.1 找出姓名集合中以张开头的姓名集合原来我们的解决方案是 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(&quot;老大&quot;); names.add(&quot;小二&quot;); names.add(&quot;张三&quot;); names.add(&quot;张四&quot;); names.add(&quot;王五&quot;); names.add(&quot;张玖&quot;); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); names.forEach(s -&gt; &#123; if (s.startsWith(&quot;张&quot;)) list.add(s); &#125;); System.out.println(list); &#125;&#125; 而使用Stream后不仅方便，代码量也大大减少，而且代码的可读性也更强 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(&quot;老大&quot;); names.add(&quot;小二&quot;); names.add(&quot;张三&quot;); names.add(&quot;张四&quot;); names.add(&quot;王五&quot;); names.add(&quot;张玖&quot;); // 过滤出以张开头的姓名，并将结果转换成List方便我们处理 List&lt;String&gt; list = names.stream() .filter(s -&gt; s.startsWith(&quot;张&quot;)) .collect(Collectors.toList()); System.out.println(list); &#125;&#125; 2.2 复杂的集合操作假定我们有一组随机生成的整数集合，我们要过滤出50及以内的数，且剔除重复元素后取前10个进行从小到大排序输出。 有点麻烦是吧？但不难，在一般情况下我们是这么操作的 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; numList = new ArrayList&lt;&gt;(200); Random random = new Random(); for (int i = 0; i &lt; 200; i++) &#123; numList.add(random.nextInt(101)); &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); numList.forEach(num -&gt; &#123; if (num &lt;= 50 &amp;&amp; !list.contains(num)) list.add(num); &#125;); List&lt;Integer&gt; tenNumbers = list.subList(0, 10); tenNumbers.sort(Comparator.comparingInt(o -&gt; o)); System.out.println(tenNumbers); &#125;&#125; 在使用Stream进行处理后，代码就变得十分简洁 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; numList = new ArrayList&lt;&gt;(200); Random random = new Random(); for (int i = 0; i &lt; 200; i++) &#123; numList.add(random.nextInt(101)); &#125; List&lt;Integer&gt; list = numList.stream() .filter(num -&gt; num &lt;= 50) .distinct() .limit(10) .sorted() .collect(Collectors.toList()); System.out.println(list); &#125;&#125; 是不是很Easy？ 3. 方法使用那么我们怎么使用Stream方便我们的开发呢？Stream的方法不多，我们一一讲解。我们先总览一下有哪些方法，一看就知道的方法就不说了 测试环境：JDK11 点开查看 方法描述builder返回一个构造器of构造Stream流filter过滤出符合要求的元素map将流中的元素映射到另一个流中mapToInt将流中元素转成int类型，其他相似方法同理flatMap合并数据flatMapToInt合并数据并转换成int类型，其他相似方法同理distinct剔除重复元素sorted从小到大排序，sorted(Comparator&lt;? super T&gt; comparator)为按一定规则进行排序peek在流（一个步骤）工作之前插入一个操作，但在这里改变元素并不会生效limit获取前n个元素，如果总元素小于n，则不进行操作skip跳过前n个元素takeWhile逐个获取符合规则的元素，遇到不符合的立马结束操作，丢弃后面的所有元素dropWhile逐个删除符合规则的元素，遇到不符合的立马结束操作，返回剩下的所有元素forEach遍历元素，在并行流中输出元素不保证与原来的一致forEachOrdered在并行流中保证输出顺序一致reduce对Stream元素进行聚合求值collect将流转成你想要的类型anyMatch只要有一个元素符合规则就返回TrueallMatch只有每个元素均符合规则时才会返回TruenoneMatch只有每个元素都不符合规则时返回TruefindAny随便返回一个元素，没错，你没看错 3.1 获取Stream流的三种方法3.1.1 builder12345678public class Main &#123; public static void main(String[] args) &#123; Stream.Builder&lt;Integer&gt; builder = Stream.builder(); builder.add(1); builder.add(2); Stream&lt;Integer&gt; stream = builder.build(); &#125;&#125; 3.1.2 of12345678910public class Main &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream1 = Stream.of(&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;); Integer[] numbers = new Integer[]&#123;1, 2, 3, 4, 5, 6&#125;; Stream&lt;Integer&gt; stream2 = Stream.of(numbers); Stream&lt;String&gt; stream3 = Stream.ofNullable(null); &#125;&#125; 3.1.3 Collection.stream()任何实现Collection接口的类均可调用stream()获取到Stream流 123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); Stream&lt;Integer&gt; stream1 = nums.stream(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); Stream&lt;String&gt; stream2 = set.stream(); Vector&lt;String&gt; vector = new Vector&lt;&gt;(); Stream&lt;String&gt; stream3 = vector.stream(); // Map不是Collection的子接口，所以需要分别处理 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); Stream&lt;String&gt; keyStream = map.keySet().stream(); Stream&lt;String&gt; valueStream = map.values().stream(); Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream(); &#125;&#125; 3.2 map将流中的元素映射到另一个流中，在这中间我们可以对元素进行处理，如以下代码是将元素转成int类型，且将456改成999 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add(&quot;123&quot;); strList.add(&quot;456&quot;); strList.add(&quot;789&quot;); List&lt;Integer&gt; nums = strList.stream().map( s -&gt; &#123; if (s.equals(&quot;456&quot;)) return 999; else return Integer.parseInt(s); &#125; ).collect(Collectors.toList()); // 输出[123, 999, 789] System.out.println(nums); &#125;&#125; 3.3 mapToInt将流中元素转成int类型，其他相似方法同理 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add(&quot;123&quot;); strList.add(&quot;456&quot;); strList.add(&quot;789&quot;); List&lt;Integer&gt; nums = strList.stream() .mapToInt(Integer::parseInt) // 注意要写上这句 .boxed() .collect(Collectors.toList()); // 输出[123, 456, 789] System.out.println(nums); &#125;&#125; 3.4 flatMap把两个列表的数据合并成一个列表数据 123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(4444); list.add(33333); list.add(444444); // 添加两次 lists.add(list); lists.add(list); System.out.println(lists); List&lt;Integer&gt; result = lists.stream().flatMap(Collection::stream).collect(Collectors.toList()); System.out.println(result); // 输出 // [[4444, 33333, 444444], [4444, 33333, 444444]] // [4444, 33333, 444444, 4444, 33333, 444444] &#125;&#125; 3.5 flatMapToInt把两个列表的数据合并成一个列表数据并将数据转成int类型 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(4444); list.add(33333); list.add(444444); // 添加两次 lists.add(list); lists.add(list); System.out.println(lists); List&lt;Integer&gt; result = lists.stream() .flatMapToInt(integers -&gt; integers.stream().mapToInt(value -&gt; value)) .boxed() .collect(Collectors.toList()); System.out.println(result); // 输出 // [[4444, 33333, 444444], [4444, 33333, 444444]] // [4444, 33333, 444444, 4444, 33333, 444444] &#125;&#125; 3.6 filter1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(&quot;老大&quot;); names.add(&quot;小二&quot;); names.add(&quot;张三&quot;); names.add(&quot;张四&quot;); names.add(&quot;王五&quot;); names.add(&quot;张玖&quot;); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); names.forEach(s -&gt; &#123; if (s.startsWith(&quot;张&quot;)) list.add(s); &#125;); // 输出[张三, 张四, 张玖] System.out.println(list); &#125;&#125; 3.7 sorted对元素进行排序 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); nums.add(5); nums.add(8); nums.add(18); nums.add(1); nums.add(15); nums.add(20); nums.add(3); System.out.println(nums); List&lt;Integer&gt; list1 = nums.stream() .sorted() .collect(Collectors.toList()); List&lt;Integer&gt; list2 = nums.stream() .sorted((o1, o2) -&gt; o2 - o1) .collect(Collectors.toList()); System.out.println(list1); System.out.println(list2); // 输出 // [5, 8, 18, 1, 15, 20, 3] // [1, 3, 5, 8, 15, 18, 20] // [20, 18, 15, 8, 5, 3, 1] &#125;&#125; 3.8 peek在流（一个步骤）工作之前插入一个操作，但在这里改变元素并不会生效 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); nums.add(5); nums.add(8); nums.add(18); nums.add(1); nums.add(15); nums.add(20); nums.add(3); nums.stream() .peek(integer -&gt; System.out.println(&quot;当前在处理：&quot; + integer)) .sorted() .peek(integer -&gt; System.out.println(&quot;当前在准备输出：&quot; + integer)) .forEach(System.out::println); &#125;&#125; 控制台 123456789101112131415161718192021当前在处理：5当前在处理：8当前在处理：18当前在处理：1当前在处理：15当前在处理：20当前在处理：3当前在准备输出：11当前在准备输出：33当前在准备输出：55当前在准备输出：88当前在准备输出：1515当前在准备输出：1818当前在准备输出：2020 3.9 limit获取前n个元素，如果总元素小于n，则不进行操作 12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); nums.add(5); nums.add(8); nums.add(18); nums.add(1); nums.add(15); nums.add(20); nums.add(3); System.out.println(nums); List&lt;Integer&gt; list1 = nums.stream() .limit(3) .collect(Collectors.toList()); List&lt;Integer&gt; list2 = nums.stream() .limit(100) .collect(Collectors.toList()); System.out.println(list1); System.out.println(list2); // 输出 // [5, 8, 18, 1, 15, 20, 3] // [5, 8, 18] // [5, 8, 18, 1, 15, 20, 3] &#125;&#125; 3.10 skip跳过前n个元素，元素小于等于n个则返回一个空流 1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); nums.add(5); nums.add(8); nums.add(18); nums.add(1); nums.add(15); nums.add(20); nums.add(3); System.out.println(nums); List&lt;Integer&gt; list = nums.stream() .skip(4) .collect(Collectors.toList()); System.out.println(list); // 输出 // [5, 8, 18, 1, 15, 20, 3] // [15, 20, 3] &#125;&#125; 3.11 takeWhile逐个获取符合规则的元素，遇到不符合的立马结束操作，丢弃后面的所有元素 1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); nums.add(5); nums.add(8); nums.add(18); nums.add(1); nums.add(15); nums.add(20); nums.add(3); System.out.println(nums); List&lt;Integer&gt; list = nums.stream() .takeWhile(integer -&gt; integer &lt; 10) .collect(Collectors.toList()); System.out.println(list); // 输出 // [5, 8, 18, 1, 15, 20, 3] // [5, 8] &#125;&#125; 3.12 dropWhile逐个删除符合规则的元素，遇到不符合的立马结束操作，返回剩下的所有元素 1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); nums.add(5); nums.add(8); nums.add(18); nums.add(1); nums.add(15); nums.add(20); nums.add(3); System.out.println(nums); List&lt;Integer&gt; list = nums.stream() .dropWhile(integer -&gt; integer != 1) .collect(Collectors.toList()); System.out.println(list); // 输出 // [5, 8, 18, 1, 15, 20, 3] // [1, 15, 20, 3] &#125;&#125; 3.13 forEach遍历元素，在并行流中输出元素不保证与原来的一致 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); nums.add(5); nums.add(8); nums.add(18); nums.add(1); nums.stream().forEach(System.out::println); // 输出 // 5 // 8 // 18 // 1 &#125;&#125; 3.14 forEachOrder在并行流中保证输出顺序一致 12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); nums.add(5); nums.add(8); nums.add(18); nums.add(1); System.out.println(nums); // forEach 发现顺序和原来的不一样 System.out.println(&quot;forEach&quot;); nums.stream().parallel().forEach(System.out::println); // forEachOrdered 顺序和原来的一样 System.out.println(&quot;forEachOrdered&quot;); nums.stream().parallel().forEachOrdered(System.out::println); // 输出 // [5, 8, 18, 1] // forEach // 18 // 1 // 5 // 8 // forEachOrdered // 5 // 8 // 18 // 1 &#125;&#125; 3.15 reduce对Stream元素进行归约 12345678910111213public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); nums.add(5); nums.add(8); nums.add(18); nums.add(1); long sum = nums.stream().reduce(Integer::sum).get(); // 5+8+18+1=32 // 输出 32 System.out.println(sum); &#125;&#125; 3.16 collect将流转成你想要的类型 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add(&quot;123&quot;); strList.add(&quot;456&quot;); strList.add(&quot;789&quot;); List&lt;Integer&gt; nums = strList.stream() .mapToInt(Integer::parseInt) .boxed() // 转换成List&lt;Integer&gt;集合 .collect(Collectors.toList()); // 输出[123, 456, 789] System.out.println(nums); &#125;&#125; 3.17 anyMatch只要有一个元素符合规则就返回True 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); nums.add(5); nums.add(8); nums.add(18); nums.add(1); boolean result1 = nums.stream().anyMatch(integer -&gt; integer == 8); // True System.out.println(result1); boolean result2 = nums.stream().anyMatch(integer -&gt; integer == 5000); // False System.out.println(result2); &#125;&#125; 3.18 allMatch只有每个元素均符合规则时才会返回True 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); nums.add(5); nums.add(8); nums.add(18); nums.add(1); boolean result1 = nums.stream().allMatch(integer -&gt; integer &lt; 8); // False System.out.println(result1); boolean result2 = nums.stream().allMatch(integer -&gt; integer &gt; 0); // True System.out.println(result2); &#125;&#125; 3.19 noneMatch只有每个元素都不符合规则时返回True 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); nums.add(5); nums.add(8); nums.add(18); nums.add(1); boolean result1 = nums.stream().noneMatch(integer -&gt; integer &lt; 8); // False System.out.println(result1); boolean result2 = nums.stream().noneMatch(integer -&gt; integer == 0); // True System.out.println(result2); &#125;&#125; 3.20 findAny随便返回一个元素，没错，你没看错 123456789101112public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); nums.add(5); nums.add(8); nums.add(18); nums.add(1); int ele = nums.stream().findAny().get(); // 输出8 System.out.println(ele); &#125;&#125; 3.21 distinct对元素进行去重操作 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); nums.add(5); nums.add(5); nums.add(8); nums.add(8); nums.add(18); nums.add(18); nums.add(1); nums.add(1); System.out.println(nums); List&lt;Integer&gt; list = nums.stream() .distinct() .collect(Collectors.toList()); // 输出 // [5, 5, 8, 8, 18, 18, 1, 1] // [5, 8, 18, 1] System.out.println(list); &#125;&#125; 4. 并行流、串行流4.1 串行流这是案例里的代码，此时我们是串行流，即在一条线程中处理 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(&quot;老大&quot;); names.add(&quot;小二&quot;); names.add(&quot;张三&quot;); names.add(&quot;张四&quot;); names.add(&quot;王五&quot;); names.add(&quot;张玖&quot;); // 过滤出以张开头的姓名，并将结果转换成List方便我们处理 List&lt;String&gt; list = names.stream() .filter(s -&gt; s.startsWith(&quot;张&quot;)) .collect(Collectors.toList()); System.out.println(list); &#125;&#125; 1234567Thread[main,5,main]Thread[main,5,main]Thread[main,5,main]Thread[main,5,main]Thread[main,5,main]Thread[main,5,main][张三, 张四, 张玖] 4.2 并行流parallelStream其实就是一个并行执行的流。它通过默认的ForkJoinPool，可能提高多线程任务的速度。可以通过以下方式获取 12345ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();// 直接获取并行的流 Stream&lt;Integer&gt; stream = list.parallelStream();// 将串行流转成并行流Stream&lt;Integer&gt; stream = list.stream().parallel(); 并行执行效果 1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(&quot;老大&quot;); names.add(&quot;小二&quot;); names.add(&quot;张三&quot;); names.add(&quot;张四&quot;); names.add(&quot;王五&quot;); names.add(&quot;张玖&quot;); // 过滤出以张开头的姓名，并将结果转换成List方便我们处理 List&lt;String&gt; list = names.stream() .parallel() .filter(s -&gt; &#123; System.out.println(Thread.currentThread()); return s.startsWith(&quot;张&quot;); &#125;) .collect(Collectors.toList()); System.out.println(list); &#125;&#125; 1234567Thread[main,5,main]Thread[ForkJoinPool.commonPool-worker-19,5,main]Thread[ForkJoinPool.commonPool-worker-23,5,main]Thread[ForkJoinPool.commonPool-worker-5,5,main]Thread[ForkJoinPool.commonPool-worker-9,5,main]Thread[ForkJoinPool.commonPool-worker-19,5,main][张三, 张四, 张玖] 4.3 执行效率对比在百万级数据处理时，串行流和并行流的耗时分别为131ms和55ms 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; names = new ArrayList&lt;&gt;(10000000); Random random = new Random(); for (int i = 0; i &lt; 10000000; i++) &#123; names.add(random.nextInt(1000)); &#125; long startTime = System.currentTimeMillis(); long sum = names.stream() .reduce(Integer::sum) .get(); // 131ms System.out.println(&quot;串行流耗时：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); startTime = System.currentTimeMillis(); long sum1 = names.parallelStream() .reduce(Integer::sum) .get(); // 55ms System.out.println(&quot;并行流耗时：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); &#125;&#125;","categories":[{"name":"教程","slug":"教程","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/"},{"name":"Java","slug":"教程/Java","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://summerain0.club/tags/Java/"}]},{"title":"git常见命令","slug":"git-common-commands","date":"2022-09-19T08:09:15.000Z","updated":"2022-09-19T15:42:36.165Z","comments":true,"path":"2022/09/19/git-common-commands/","link":"","permalink":"https://summerain0.club/2022/09/19/git-common-commands/","excerpt":"","text":"命令 用法 描述 git config git config –global user.name&#x2F;user.email [username&#x2F;email address] 设置提交代码的用户名和电子邮件地址 git init git init [name] 创建一个新的代码库 git clone git clone [url] 通过指定的URL获取一个代码库 git add git add [file] 将一个文件添加至stage git commit git commit -m “message” 版本历史记录中永久记录文件 git diff git diff 显示尚未添加到stage的文件的变更 git reset git reset [file] 从stage中撤出指定的文件，但可以保留文件的内容 git status git status 显示所有需要提交的文件 git rm git rm [file] 删除工作目录中的文件，并将删除动作添加到stage git log git log 显示当前分支的版本历史记录 git show git show [commit] 显示指定提交的元数据以及内容变更 git tag git tag [commitID] 给指定的提交添加标签 git branch git branch 显示当前代码库中所有的本地分支 git checkout git checkout [branch name] 切换分支 git merge git merge [branch name] 将指定分支的历史记录合并到当前分支 git remote git remote add [variable name] [Remote Server Link] 将本地的代码库连接到远程服务器 git push git push [variable name] master 将主分支上提交的变更发送到远程代码库 git pull git pull [Repository Link] 获取远程服务器上的变更，并合并到你的工作目录 git stash git stash save 临时保存所有修改的文件","categories":[{"name":"笔记","slug":"笔记","permalink":"https://summerain0.club/categories/%E7%AC%94%E8%AE%B0/"},{"name":"git","slug":"笔记/git","permalink":"https://summerain0.club/categories/%E7%AC%94%E8%AE%B0/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://summerain0.club/tags/git/"}]},{"title":"Android Material Design的使用（一）- MaterialButton篇","slug":"material-design-materialbutton","date":"2022-09-04T06:21:39.000Z","updated":"2022-09-04T09:33:05.323Z","comments":true,"path":"2022/09/04/material-design-materialbutton/","link":"","permalink":"https://summerain0.club/2022/09/04/material-design-materialbutton/","excerpt":"","text":"前言本系列将要介绍Material design库包含的所有控件，当前文章基于 com.google.android.material:material:1.4.0 讲解 MaterialButtonWhat is MaterialButton?MaterialButton是Google于SDK28推出的新控件，当遇到按钮需要圆角、或者描边等，就不必使用xml文件或者Github上找第三方库实现。 MaterialButtonhttps://developer.android.google.cn/reference/com/google/android/material/button/MaterialButton 效果图 实际运用效果如图片最后一个按钮 123456789101112&lt;com.google.android.material.button.MaterialButton android:layout_width=&quot;150dp&quot; android:layout_height=&quot;50dp&quot; android:text=&quot;后置着色&quot; android:textAllCaps=&quot;false&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot; android:theme=&quot;@style/Theme.MaterialComponents.Light.NoActionBar&quot; app:cornerRadius=&quot;10dp&quot; app:icon=&quot;@drawable/ic_android_black_24dp&quot; app:iconGravity=&quot;textEnd&quot; app:iconTint=&quot;#ff0000&quot; /&gt; 啥？闪退了？那就删除吧 关于闪退问题在v1.1.0以后，使用MD控件可能会出现闪退的问题，原因是未将theme设置为MaterialComponents，解决方法如下： 方法一在控件中添加 1android:theme=&quot;@style/Theme.MaterialComponents.Light.NoActionBar&quot; 即可解决 方法二123&lt;style name=&quot;MaterialComponents_Theme&quot; parent=&quot;Theme.MaterialComponents.Light.NoActionBar&quot;&gt;...&lt;/style&gt; 然后设置App主题为@style&#x2F;MaterialComponents_Theme即可 常见问题关于Backgroundnote quote All attributes from MaterialButton are supported. Do not use the android:background attribute. MaterialButton manages its own background drawable, and setting a new background means MaterialButton can no longer guarantee that the new attributes it introduces will function properly. If the default background is changed, MaterialButton cannot guarantee well-defined behavior. 大意就是不可以使用android:background设置背景，会破坏MaterialButton本身的绘制，而设置背景则推荐使用app:backgroundTint 关于insetTop、insetBottomMaterialButton创建后，按钮实际长度并不是设定值，因为它上下有留空，可以使用 12android:insetBottom=&quot;0dp&quot;android:insetTop=&quot;0dp&quot; 去除。 去除阴影MD控件默认有阴影效果，但是有时候我们并不想要按钮有阴影，那么这时候可以指定style为 1style=&quot;@style/Widget.MaterialComponents.Button.UnelevatedButton&quot; 这样就能去掉阴影，让视图看起来扁平化。 公开属性 属性 描述 参数 app:backgroundTint 背景着色 默认为?attr&#x2F;colorPrimary app:backgroundTintMode 着色模式 add,multiply,screen,src_atop,src_in,src_over app:strokeColor 描边颜色 app:strokeWidth 描边宽度 app:cornerRadius 圆角大小 app:rippleColor 按压水波纹颜色 app:icon 图标icon app:iconSize 图标大小 app:iconGravity 图标重心 start,end.textStart,textEnd app:iconTint 图标着色 app:iconTintMode 图标着色模式 add,multiply,screen,src_atop,src_in,src_over app:iconPadding 图标和文本之间的间距 项目完整源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;普通按钮&quot; /&gt; &lt;com.google.android.material.button.MaterialButton android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Material&quot; android:textAllCaps=&quot;false&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot; android:theme=&quot;@style/Theme.MaterialComponents.Light.NoActionBar&quot; /&gt; &lt;com.google.android.material.button.MaterialButton android:layout_width=&quot;150dp&quot; android:layout_height=&quot;50dp&quot; android:text=&quot;圆角 10dp&quot; android:textAllCaps=&quot;false&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot; android:theme=&quot;@style/Theme.MaterialComponents.Light.NoActionBar&quot; app:cornerRadius=&quot;10dp&quot; /&gt; &lt;com.google.android.material.button.MaterialButton android:layout_width=&quot;150dp&quot; android:layout_height=&quot;50dp&quot; android:text=&quot;描边 2dp&quot; android:textAllCaps=&quot;false&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot; android:theme=&quot;@style/Theme.MaterialComponents.Light.NoActionBar&quot; app:strokeColor=&quot;#ff0000&quot; app:strokeWidth=&quot;2dp&quot; /&gt; &lt;com.google.android.material.button.MaterialButton android:layout_width=&quot;150dp&quot; android:layout_height=&quot;50dp&quot; android:text=&quot;图标&quot; android:textAllCaps=&quot;false&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot; android:theme=&quot;@style/Theme.MaterialComponents.Light.NoActionBar&quot; app:cornerRadius=&quot;10dp&quot; app:icon=&quot;@drawable/ic_android_black_24dp&quot; /&gt; &lt;com.google.android.material.button.MaterialButton android:layout_width=&quot;150dp&quot; android:layout_height=&quot;50dp&quot; android:text=&quot;后置着色&quot; android:textAllCaps=&quot;false&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot; android:theme=&quot;@style/Theme.MaterialComponents.Light.NoActionBar&quot; app:cornerRadius=&quot;10dp&quot; app:icon=&quot;@drawable/ic_android_black_24dp&quot; app:iconGravity=&quot;textEnd&quot; app:iconTint=&quot;#ff0000&quot; /&gt;&lt;/LinearLayout&gt; MaterialButtonToggleGroup什么是MaterialButtonToggleGroup？类似一个LinearLayout，但只能添加MaterialButton，只有第一个子元素的最左边角和最后一个子元素的最右边角才能保留它们的形状外观或角大小，类似于iOS中的SegmentedControl，用户可以从组中选择一个或多个选项。 MaterialButtonhttps://developer.android.google.cn/reference/com/google/android/material/button/MaterialButtonToggleGroup 举个栗子布局源码12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;com.google.android.material.button.MaterialButtonToggleGroup xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/toggleGroup&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:checkedButton=&quot;@id/btn1&quot; app:singleSelection=&quot;true&quot;&gt; &lt;com.google.android.material.button.MaterialButton android:id=&quot;@+id/btn1&quot; style=&quot;@style/Widget.MaterialComponents.Button.OutlinedButton&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;选项一&quot; android:theme=&quot;@style/Theme.MaterialComponents.Light.NoActionBar&quot; /&gt; &lt;com.google.android.material.button.MaterialButton android:id=&quot;@+id/btn2&quot; style=&quot;@style/Widget.MaterialComponents.Button.OutlinedButton&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;选项二&quot; android:theme=&quot;@style/Theme.MaterialComponents.Light.NoActionBar&quot; /&gt; &lt;com.google.android.material.button.MaterialButton android:id=&quot;@+id/btn3&quot; style=&quot;@style/Widget.MaterialComponents.Button.OutlinedButton&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;选项三&quot; android:theme=&quot;@style/Theme.MaterialComponents.Light.NoActionBar&quot; /&gt;&lt;/com.google.android.material.button.MaterialButtonToggleGroup&gt; 监听方法1234567MaterialButtonToggleGroup materialButtonToggleGroup = findViewById(R.id.toggleGroup);materialButtonToggleGroup.addOnButtonCheckedListener(new MaterialButtonToggleGroup.OnButtonCheckedListener() &#123; @Override public void onButtonChecked(MaterialButtonToggleGroup group, int checkedId, boolean isChecked) &#123; Toast.makeText(MainActivity.this, &quot;ID：&quot; + checkedId + &quot;, checked：&quot; + isChecked, Toast.LENGTH_SHORT).show(); &#125;&#125;); 公开属性 属性 描述 参数 app:checkedButton 默认选中 按钮ID app:singleSelection 是否单项选择 true&#x2F;false app:selectionRequired 设置为true后，强制至少选中一个 true&#x2F;false","categories":[{"name":"教程","slug":"教程","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/"},{"name":"Android","slug":"教程/Android","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/Android/"},{"name":"Material Design","slug":"教程/Android/Material-Design","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/Android/Material-Design/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://summerain0.club/tags/Android/"},{"name":"Material Design","slug":"Material-Design","permalink":"https://summerain0.club/tags/Material-Design/"},{"name":"Button","slug":"Button","permalink":"https://summerain0.club/tags/Button/"}]},{"title":"Android自定义全局异常捕获——Activity形式","slug":"activity-uncaught-exception","date":"2022-09-03T15:57:30.000Z","updated":"2022-09-03T16:16:40.283Z","comments":true,"path":"2022/09/03/activity-uncaught-exception/","link":"","permalink":"https://summerain0.club/2022/09/03/activity-uncaught-exception/","excerpt":"","text":"前言开发安卓的小伙伴都遇到过APP突然崩溃,无响应的情况.如果发生在自己手中,那么还可以通过IDE查看错误日志,但是实际都是发生在用户手中,那么这个时候产生崩溃,无响应ANR异常就很麻烦.无从下手.因此,需要全局异常捕获.也就是对未知异常,程序员没有处理的异常进行处理,记录等便于分析查找原因，而一个美观的崩溃提示则可以大大加分 。 效果展示效果展示 源码MyUncaughtExceptionHandler.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152import android.content.Context;import android.content.Intent;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import android.os.Build;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.PrintWriter;import java.io.StringWriter;import java.io.Writer;import java.lang.reflect.Field;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Arrays;import java.util.Date;import java.util.Locale;/** * @ClassName MyUncaughtExceptionHandler * @Description 全局捕捉异常 * @Author summerain0 * @Date 2020/9/11 15:31 */public class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler &#123; // 单例 private static MyUncaughtExceptionHandler myUncaughtExceptionHandler; // 上下文 private Context context; // 会输出到文件中 private StringBuilder stringBuilder; // 系统异常处理器 private Thread.UncaughtExceptionHandler defaultUncaughtExceptionHandler; public MyUncaughtExceptionHandler(Context context) &#123; this.context = context; &#125; // 获取单例 public static synchronized MyUncaughtExceptionHandler getInstance(Context ctx) &#123; if (myUncaughtExceptionHandler == null) &#123; myUncaughtExceptionHandler = new MyUncaughtExceptionHandler(ctx); &#125; return myUncaughtExceptionHandler; &#125; // 初始化 public void init() &#123; defaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler(); Thread.setDefaultUncaughtExceptionHandler(this); &#125; @Override public void uncaughtException(Thread thread, Throwable throwable) &#123; if (throwable == null) &#123; defaultUncaughtExceptionHandler.uncaughtException(thread, throwable); &#125; // 创建集合对象 stringBuilder = new StringBuilder(); // 记录时间 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd_HH:mm:ss.SSS&quot;, Locale.getDefault()); String date = simpleDateFormat.format(new Date()); addMessage(&quot;崩溃时间&quot;, date); // 记录应用版本信息 try &#123; PackageManager pm = context.getPackageManager(); PackageInfo pi = pm.getPackageInfo(context.getPackageName(), PackageManager.GET_ACTIVITIES); addMessage(&quot;版本名&quot;, pi.versionName); addMessage(&quot;版本号&quot;, pi.versionCode); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); addMessage(&quot;error&quot;, &quot;记录版本信息失败！&quot; + e.getMessage()); &#125; // 记录设备信息 Field[] fields = Build.class.getDeclaredFields(); for (Field field : fields) &#123; try &#123; field.setAccessible(true); Object obj = field.get(null); if (obj != null) &#123; addMessage(field.getName(), obj); &#125; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); addMessage(&quot;error&quot;, &quot;记录设备信息失败！&quot; + e.getMessage()); &#125; &#125; // 添加分隔符 addMessage(null, &quot;==============================================================&quot;); addMessage(null, &quot;======================== 崩溃日志 =========================&quot;); addMessage(null, &quot;==============================================================&quot;); // 记录崩溃信息 Writer writer = new StringWriter(); PrintWriter printWriter = new PrintWriter(writer); throwable.printStackTrace(printWriter); Throwable cause = throwable.getCause(); while (cause != null) &#123; cause.printStackTrace(printWriter); cause = cause.getCause(); &#125; printWriter.close(); addMessage(null, writer.toString()); // 生成路径，保存至/Android/data/包名，无需读写权限 try &#123; File root = context.getExternalFilesDir(&quot;log&quot;); String filename = date + &quot;.log&quot;; File file = new File(root, filename); FileOutputStream fos = new FileOutputStream(file); fos.write(stringBuilder.toString().getBytes()); fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); defaultUncaughtExceptionHandler.uncaughtException(thread, throwable); &#125; // 启动崩溃异常页面 Intent intent = new Intent(context, UncaughtExceptionActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);// 请勿修改，否则无法打开页面 intent.putExtra(&quot;error&quot;, stringBuilder.toString()); context.startActivity(intent); System.exit(1);// 请勿修改，否则无法打开页面 &#125; // 添加数据 private void addMessage(String key, Object obj) &#123; // 对数组做一下处理 if (obj instanceof String[]) &#123; String[] list = (String[]) obj; ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;(Arrays.asList(list)); stringBuilder.append(key).append(&quot;=&quot;).append(array.toString()).append(&quot;\\n&quot;); &#125; // 其他的都直接添加 if (key == null) &#123; stringBuilder.append(obj) .append(&quot;\\n&quot;); &#125; else &#123; stringBuilder.append(key) .append(&quot;=&quot;) .append(obj) .append(&quot;\\n&quot;); &#125; &#125;&#125; UncaughtExceptionActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import android.content.Intent;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.widget.ScrollView;import android.widget.TextView;import android.widget.Toast;import androidx.appcompat.app.AppCompatActivity;/** * @ClassName UncaughtExceptionActivity * @Description 异常页面 * @Author summerain0 * @Date 2020/9/12 11:02 */public class UncaughtExceptionActivity extends AppCompatActivity &#123; public static final String TAG = &quot;UncaughtExceptionActivity&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 读取日志，显示在屏幕上 String msg = getIntent().getStringExtra(&quot;error&quot;); ScrollView scrollView = new ScrollView(this);// 防止日志太长看不完 scrollView.setLayoutParams(new ScrollView.LayoutParams(ScrollView.LayoutParams.MATCH_PARENT, ScrollView.LayoutParams.MATCH_PARENT)); TextView textView = new TextView(this); textView.setText(msg); scrollView.addView(textView); setContentView(scrollView); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; menu.add(0, 0, 0, &quot;重启&quot;).setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM); menu.add(0, 1, 0, &quot;上传&quot;).setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM); return super.onCreateOptionsMenu(menu); &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case 0: Intent intent = new Intent(this, MainActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);// 请勿修改，否则无法打开页面 startActivity(intent); System.exit(1);// 请勿修改，否则无法打开页面 case 1: // 这里自己写上传逻辑 Toast.makeText(this, &quot;已上传！&quot;, Toast.LENGTH_SHORT).show(); &#125; return true; &#125;&#125; MyApplication.java123456789101112131415161718import android.app.Application;/** * @ClassName MyApplication * @Description TODO * @Author summerain0 * @Date 2020/9/11 14:00 */public class MyApplication extends Application &#123; public static final String TAG = &quot;MyApplication&quot;; @Override public void onCreate() &#123; super.onCreate(); // 初始化异常处理器 MyUncaughtExceptionHandler.getInstance(MyApplication.this).init(); &#125;&#125; AndroidManifest.xml123456789&lt;application android:name=&quot;.MyApplication&quot; ......&gt; &lt;activity android:label=&quot;崩溃异常&quot; android:name=&quot;.UncaughtExceptionActivity&quot; /&gt;&lt;/application&gt;","categories":[{"name":"教程","slug":"教程","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/"},{"name":"Android","slug":"教程/Android","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://summerain0.club/tags/Android/"}]},{"title":"自定义全局异常捕捉——保存至本地","slug":"file-uncaught-exception","date":"2022-09-03T15:57:30.000Z","updated":"2022-09-03T16:03:34.516Z","comments":true,"path":"2022/09/03/file-uncaught-exception/","link":"","permalink":"https://summerain0.club/2022/09/03/file-uncaught-exception/","excerpt":"","text":"前言开发安卓的小伙伴都遇到过APP突然崩溃,无响应的情况.如果发生在自己手中,那么还可以通过IDE查看错误日志,但是实际都是发生在用户手中,那么这个时候产生崩溃,无响应ANR异常就很麻烦.无从下手.因此,需要全局异常捕获.也就是对未知异常,程序员没有处理的异常进行处理,记录等便于分析查找原因. 源码MyUncaughtExceptionHandler.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import android.content.Context;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import android.os.Build;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.PrintWriter;import java.io.StringWriter;import java.io.Writer;import java.lang.reflect.Field;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Arrays;import java.util.Date;import java.util.Locale;/** * @ClassName MyUncaughtExceptionHandler * @Description 全局捕捉异常 * @Author summerain0 * @Date 2020/9/11 15:31 */public class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler &#123; // 单例 private static MyUncaughtExceptionHandler myUncaughtExceptionHandler; // 上下文 private Context context; // 会输出到文件中 private StringBuilder stringBuilder; // 系统异常处理器 private Thread.UncaughtExceptionHandler defaultUncaughtExceptionHandler; public MyUncaughtExceptionHandler(Context context) &#123; this.context = context; &#125; // 获取单例 public static synchronized MyUncaughtExceptionHandler getInstance(Context ctx) &#123; if (myUncaughtExceptionHandler == null) &#123; myUncaughtExceptionHandler = new MyUncaughtExceptionHandler(ctx); &#125; return myUncaughtExceptionHandler; &#125; // 初始化 public void init() &#123; defaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler(); Thread.setDefaultUncaughtExceptionHandler(this); &#125; @Override public void uncaughtException(Thread thread, Throwable throwable) &#123; if (throwable == null) &#123; defaultUncaughtExceptionHandler.uncaughtException(thread, throwable); &#125; // 创建集合对象 stringBuilder = new StringBuilder(); // 记录时间 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd_HH:mm:ss.SSS&quot;, Locale.getDefault()); String date = simpleDateFormat.format(new Date()); addMessage(&quot;崩溃时间&quot;, date); // 记录应用版本信息 try &#123; PackageManager pm = context.getPackageManager(); PackageInfo pi = pm.getPackageInfo(context.getPackageName(), PackageManager.GET_ACTIVITIES); addMessage(&quot;版本名&quot;, pi.versionName); addMessage(&quot;版本号&quot;, pi.versionCode); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); addMessage(&quot;error&quot;, &quot;记录版本信息失败！&quot; + e.getMessage()); &#125; // 记录设备信息 Field[] fields = Build.class.getDeclaredFields(); for (Field field : fields) &#123; try &#123; field.setAccessible(true); Object obj = field.get(null); if (obj != null) &#123; addMessage(field.getName(), obj); &#125; &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); addMessage(&quot;error&quot;, &quot;记录设备信息失败！&quot; + e.getMessage()); &#125; &#125; // 添加分隔符 addMessage(null, &quot;==============================================================&quot;); addMessage(null, &quot;======================== 崩溃日志 =========================&quot;); addMessage(null, &quot;==============================================================&quot;); // 记录崩溃信息 Writer writer = new StringWriter(); PrintWriter printWriter = new PrintWriter(writer); throwable.printStackTrace(printWriter); Throwable cause = throwable.getCause(); while (cause != null) &#123; cause.printStackTrace(printWriter); cause = cause.getCause(); &#125; printWriter.close(); addMessage(null, writer.toString()); // 生成路径，保存至/Android/data/包名，无需读写权限 try &#123; File root = context.getExternalFilesDir(&quot;log&quot;); String filename = date + &quot;.log&quot;; File file = new File(root, filename); FileOutputStream fos = new FileOutputStream(file); fos.write(stringBuilder.toString().getBytes()); fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); defaultUncaughtExceptionHandler.uncaughtException(thread, throwable); &#125; &#125; // 添加数据 private void addMessage(String key, Object obj) &#123; // 对数组做一下处理 if (obj instanceof String[]) &#123; String[] list = (String[]) obj; ArrayList&amp;lt;String&amp;gt; array = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(list)); stringBuilder.append(key).append(&quot;=&quot;).append(array.toString()).append(&quot;\\n&quot;); &#125; // 其他的都直接添加 if (key == null) &#123; stringBuilder.append(obj) .append(&quot;\\n&quot;); &#125; else &#123; stringBuilder.append(key) .append(&quot;=&quot;) .append(obj) .append(&quot;\\n&quot;); &#125; &#125;&#125; MyApplication.java123456789101112131415161718import android.app.Application;/** * @ClassName MyApplication * @Description TODO * @Author summerain0 * @Date 2020/9/11 14:00 */public class MyApplication extends Application &#123; public static final String TAG = &quot;MyApplication&quot;; @Override public void onCreate() &#123; super.onCreate(); // 初始化异常处理器 MyUncaughtExceptionHandler.getInstance(MyApplication.this).init(); &#125;&#125; AndroidManifest.xml1234&lt;application android:name=&quot;.MyApplication&quot; ....&gt;&lt;/application&gt;","categories":[{"name":"教程","slug":"教程","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/"},{"name":"Android","slug":"教程/Android","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://summerain0.club/tags/Android/"}]},{"title":"还在用老办法获取版本号或者签名信息吗？不如试试PackageInfoCompat吧！","slug":"android-package-info-compat","date":"2022-09-03T14:14:20.000Z","updated":"2022-09-04T08:33:04.582Z","comments":true,"path":"2022/09/03/android-package-info-compat/","link":"","permalink":"https://summerain0.club/2022/09/03/android-package-info-compat/","excerpt":"","text":"前言之前的很久时间，我们都是使用以下的方式获取应用的版本号，但在Android SDK 28中，谷歌弃用了该方式，推荐使用getLongVersionCode() 12345678910public int getSelfVersionCode(Context context)&#123; try &#123; PackageManager packageManager = context.getPackageManager(); PackageInfo info = packageManager.getPackageInfo(context.getPackageName(),0); return info.versionCode; &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); return -1; &#125;&#125; 但 getLongVersionCode() 仅限API28及以上使用，所以我们需要判断版本号并做出对应处理。 那么，我们可以一步到位吗？ 答案是可以的！ PackageInfoCompat引入依赖12345// Androidximplementation &#x27;androidx.appcompat:appcompat:1.3.0-rc01&#x27;// Android Supportimplementation &#x27;com.android.support:appcompat-v7:28.0.0&#x27; What is PackageInfoCompat？PackageInfoCompat顾名思义，是用来代替PackageInfo部分功能的，里面仅包含三个静态方法 修饰符 方法参数 方法作用 static Long getLongVersionCode( info: PackageInfo) 返回版本号 static MutableList&lt;Signature!&gt; getSignatures( packageManager: PackageManager, packageName: String) 获取签名数组 static Boolean hasSignatures( packageManager: PackageManager, packageName: String,certificatesAndType: MutableMap&lt;ByteArray!, Int!&gt;, matchExact: Boolean) 检查设备上的包是否包含一组证书。 使用getLongVersionCode - 获取版本号，内部实现其实与上文提到的方法无异 JavaKotlin内部实现12345678910public long getSelfVersionCode(Context context) &#123; try &#123; PackageManager packageManager = context.getPackageManager(); PackageInfo info = packageManager.getPackageInfo(context.getPackageName(), 0); return PackageInfoCompat.getLongVersionCode(info); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); return -1; &#125;&#125;12345fun getSelfVersionCode(context: Context): Long &#123; val packageManager = context.packageManager val info = packageManager.getPackageInfo(context.packageName, 0) return PackageInfoCompat.getLongVersionCode(info)&#125;1234567@SuppressWarnings(&quot;deprecation&quot;)public static long getLongVersionCode(@NonNull PackageInfo info) &#123; if (Build.VERSION.SDK_INT &gt;= 28) &#123; return info.getLongVersionCode(); &#125; return info.versionCode;&#125; getSignatures - 获取应用签名， signatures 在SDK28中被 signingInfo 替代 JavaKotlin1234567891011121314151617181920public String getSelfSignToSHA1(Context context) &#123; try &#123; PackageManager packageManager = context.getPackageManager(); List&lt;Signature&gt; signatureList = PackageInfoCompat.getSignatures(packageManager,context.getPackageName()); byte[] cert = signatureList.get(0).toByteArray(); MessageDigest md = MessageDigest.getInstance(&quot;SHA1&quot;); byte[] publicKey = md.digest(cert); StringBuilder hexString = new StringBuilder(); for (int i = 0; i &lt; publicKey.length; i++) &#123; String appendString = Integer.toHexString(0xFF &amp; publicKey[i]).toUpperCase(Locale.US); if (appendString.length() == 1)hexString.append(&quot;0&quot;); hexString.append(appendString); if (i != publicKey.length - 1) hexString.append(&quot;:&quot;); &#125; return hexString.toString(); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125;&#125;12345678910111213141516fun getSelfSign(context: Context): String &#123; val packageManager = context.packageManager val signatures = PackageInfoCompat.getSignatures(packageManager, context.packageName) val bytes = signatures[0].toByteArray() val messageDigest = MessageDigest.getInstance(&quot;SHA1&quot;) val publicKey: ByteArray = messageDigest.digest(bytes) val hexString = StringBuilder() for (i in publicKey.indices) &#123; val appendString = Integer.toHexString(0xFF and publicKey[i].toInt()) .toUpperCase(Locale.US) if (appendString.length == 1) hexString.append(&quot;0&quot;) hexString.append(appendString) if (i != publicKey.size - 1) hexString.append(&quot;:&quot;) &#125; return hexString.toString()&#125;","categories":[{"name":"教程","slug":"教程","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/"},{"name":"Android","slug":"教程/Android","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://summerain0.club/tags/Android/"}]},{"title":"Android Compose - 官方SwipeRefreshLayout（下拉刷新）","slug":"jetpack-compose-swipe-refresh-layout","date":"2022-09-03T11:05:11.000Z","updated":"2022-09-03T14:12:46.708Z","comments":true,"path":"2022/09/03/jetpack-compose-swipe-refresh-layout/","link":"","permalink":"https://summerain0.club/2022/09/03/jetpack-compose-swipe-refresh-layout/","excerpt":"","text":"Demo 引入依赖1234567repositories &#123; mavenCentral()&#125;dependencies &#123; implementation &quot;com.google.accompanist:accompanist-swiperefresh:&lt;version&gt;&quot;&#125; 使用方法1234567891011121314151617181920212223242526272829303132class MyViewModel : ViewModel() &#123; private val _isRefreshing = MutableStateFlow(false) val isRefreshing: StateFlow&lt;Boolean&gt; get() = _isRefreshing.asStateFlow() fun refresh() &#123; viewModelScope.launch &#123; // 延迟2秒 _isRefreshing.emit(true) delay(2000) _isRefreshing.emit(false) &#125; &#125;&#125;@Composablefun SwipeRefreshSample() &#123; val viewModel: MyViewModel = viewModel() val isRefreshing by viewModel.isRefreshing.collectAsState() SwipeRefresh( state = rememberSwipeRefreshState(isRefreshing), onRefresh = &#123; viewModel.refresh() &#125;, ) &#123; LazyColumn &#123; items(30) &#123; index -&gt; // item列表 &#125; &#125; &#125;&#125;","categories":[{"name":"教程","slug":"教程","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/"},{"name":"Jetpack Compose","slug":"教程/Jetpack-Compose","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/Jetpack-Compose/"}],"tags":[{"name":"Jetpack Compose","slug":"Jetpack-Compose","permalink":"https://summerain0.club/tags/Jetpack-Compose/"}]},{"title":"SpringBoot的MyBatis简单配置","slug":"springboot-mybatis-config","date":"2022-09-03T05:58:01.000Z","updated":"2022-09-03T15:59:26.841Z","comments":true,"path":"2022/09/03/springboot-mybatis-config/","link":"","permalink":"https://summerain0.club/2022/09/03/springboot-mybatis-config/","excerpt":"","text":"1. 引入依赖1.1 修改pom.xml123456789101112&lt;!-- mysql 驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.29&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 1.2 修改配置 application.yml123mybatis: mapper-locations: classpath:mapping/*Mapper.xml type-aliases-package: com.summerain0.cloud.common.core.domain.entity 参数讲解注意 mapper-locations 表示映射文件储存的地方，例如 classpath:mapping&#x2F;*Mapper.xml 指代resources文件夹下mapping里所有Mapper.xml结尾的文件type-aliases-package 是实体类所在的位置 自此，MyBatis的引入完成 2. 小小的例子2.1 建立实体类1234567891011import lombok.Data;import lombok.ToString;@Data@ToStringpublic class SysUser &#123; private Integer id; private String username; private String password; private String nick;&#125; 2.2 建立映射类1234@Repositorypublic interface UserMapper &#123; SysUser findById(int id);&#125; 同时在resources的mapping文件里建立一个和映射类同名的xml文件 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.summerain0.cloud.system.mapper.UserMapper&quot;&gt; &lt;resultMap id=&quot;SysUser&quot; type=&quot;com.summerain0.cloud.common.core.domain.entity.SysUser&quot;&gt; &lt;result column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;password&quot;/&gt; &lt;result column=&quot;nick&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;nick&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;findById&quot; resultType=&quot;com.summerain0.cloud.common.core.domain.entity.SysUser&quot;&gt; select * from sys_user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 2.3 建立测试方法123456789101112131415161718public interface UserService &#123; SysUser findById(int id);&#125;@Servicepublic class IUserService implements UserService &#123; private UserMapper userMapper; @Override public SysUser findById(int id) &#123; return userMapper.findById(id); &#125; @Autowired public void setUserMapper(UserMapper userMapper) &#123; this.userMapper = userMapper; &#125;&#125; 2.4 提供接口1234567891011121314@RestControllerpublic class TestController &#123; private IUserService userService; @RequestMapping(&quot;/test&quot;) public String test() &#123; return userService.findById(3).toString(); &#125; @Autowired public void setUserService(IUserService userService) &#123; this.userService = userService; &#125;&#125; 2.5 测试结果运行结果 3. 常见问题3.1 找不到Mapper？在启动类加入@MapperScan(“com.summerain0.cloud.system.mapper”)即可 1234567@MapperScan(&quot;com.summerain0.cloud.system.mapper&quot;)@SpringBootApplicationpublic class CloudApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CloudApplication.class, args); &#125;&#125;","categories":[{"name":"教程","slug":"教程","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/"},{"name":"SpringBoot","slug":"教程/SpringBoot","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://summerain0.club/tags/SpringBoot/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://summerain0.club/tags/MyBatis/"}]},{"title":"什么？你是学生？还不快来白嫖JetBrains全家桶？","slug":"jetbrains-education-license","date":"2022-09-02T12:28:29.000Z","updated":"2022-09-04T06:04:38.386Z","comments":true,"path":"2022/09/02/jetbrains-education-license/","link":"","permalink":"https://summerain0.club/2022/09/02/jetbrains-education-license/","excerpt":"","text":"前言白嫖原理是JetBrains为学生提供的免费许可证，本篇文章使用学信网进行获取免费的许可证 准备工作学信网获取学籍验证报告 登录学信网，没有账号的请自行注册 学信网登录页面 申请验证报告，完成后结果应和下图差不多一致 申请验证报告 下载验证报告备用 申请许可证 进入免费许可证申请页面 申请教育许可证https://www.jetbrains.com/shop/eform/students 填写相关信息（图片约334k，请耐心等待加载） 教程图片 大约一到三周即可收到邮件（最快次日即可收到） 申请成功通知邮件 注册JetBrains账号（已注册可省略此步骤）注册JetBrains账号https://account.jetbrains.com/login PS：注意使用申请时填写的邮箱，注册后会自动绑定许可证 使用许可证Help -&gt; Register -&gt; 输入账号密码确认即可 IDEA许可证页面IDEA已许可页面 注意事项许可证适用于JetBrains全家桶申请后许可证有效期为一年，可重复申请白嫖可白嫖的软件，建议下载JetBrains ToolBox进行管理AppCodeCLionDataGripdotCoverdotMemorydotTraceGoLandIntelliJ IDEA UltimatePhpStormPyCharmReSharperReSharper C++RiderRubyMineWebStorm","categories":[{"name":"教程","slug":"教程","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"JetBrains","slug":"JetBrains","permalink":"https://summerain0.club/tags/JetBrains/"},{"name":"白嫖","slug":"白嫖","permalink":"https://summerain0.club/tags/%E7%99%BD%E5%AB%96/"}]}],"categories":[{"name":"教程","slug":"教程","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/"},{"name":"Java","slug":"教程/Java","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://summerain0.club/categories/%E7%AC%94%E8%AE%B0/"},{"name":"git","slug":"笔记/git","permalink":"https://summerain0.club/categories/%E7%AC%94%E8%AE%B0/git/"},{"name":"Android","slug":"教程/Android","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/Android/"},{"name":"Material Design","slug":"教程/Android/Material-Design","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/Android/Material-Design/"},{"name":"Jetpack Compose","slug":"教程/Jetpack-Compose","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/Jetpack-Compose/"},{"name":"SpringBoot","slug":"教程/SpringBoot","permalink":"https://summerain0.club/categories/%E6%95%99%E7%A8%8B/SpringBoot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://summerain0.club/tags/Java/"},{"name":"git","slug":"git","permalink":"https://summerain0.club/tags/git/"},{"name":"Android","slug":"Android","permalink":"https://summerain0.club/tags/Android/"},{"name":"Material Design","slug":"Material-Design","permalink":"https://summerain0.club/tags/Material-Design/"},{"name":"Button","slug":"Button","permalink":"https://summerain0.club/tags/Button/"},{"name":"Jetpack Compose","slug":"Jetpack-Compose","permalink":"https://summerain0.club/tags/Jetpack-Compose/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://summerain0.club/tags/SpringBoot/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://summerain0.club/tags/MyBatis/"},{"name":"JetBrains","slug":"JetBrains","permalink":"https://summerain0.club/tags/JetBrains/"},{"name":"白嫖","slug":"白嫖","permalink":"https://summerain0.club/tags/%E7%99%BD%E5%AB%96/"}]}